// Code generated by ChatGPT, edited for functionality and coherence by Tony Imbesi

// Function to fetch JSON data
async function fetchJSON(url) {
    const response = await fetch(url);
    return response.json();
}


// Initialize the conversation viewer
async function initializeConversationViewer() {
    const convoContainer = document.getElementById('conversation-container');
    const conversationListContainer = document.getElementById('conversation-list');

    // Fetch and parse your JSON data
    const conversationData = await fetchJSON('/data');

    var conversation = null;

    function renderConversationList() {
        
        console.log(conversationListContainer);
    
        conversationData.forEach((conversation) => {
            const conversationLink = document.createElement('div');
            conversationLink.className = 'conversation-link';
            conversationLink.innerHTML = conversation.title;
            conversationLink.addEventListener('click', () => renderConversation(conversation.id));
            conversationListContainer.appendChild(conversationLink);
        });
    }
    

    renderConversationList();

    // Function to render all the messages on a layer.
    /*
        @params
        messagesArray array of message ids that share the same parent
        msg id of the message to display in the message div added to the convo container
    */
    function renderMsgLayer(messagesArray, msgId, parentContainer) {
        const layerDiv = document.createElement('div')
        layerDiv.className = 'layer-container';

        const authorDiv = document.createElement('div')
        authorDiv.className = 'author-container';

        const messageDiv = document.createElement('div');
        messageDiv.className = 'message-container';

        const childDiv = document.createElement('div');
        childDiv.className = 'children-container';

        const authorRole = getMessage(msgId).message.author.role.toUpperCase();
        showAuthor(authorDiv, authorRole);
        showMessage(messageDiv, msgId);

        layerDiv.appendChild(authorDiv);
        parentContainer.appendChild(layerDiv);
        parentContainer.appendChild(childDiv);

        
        if (messagesArray.length > 1) {
            const arrowContainer = document.createElement('div');
            arrowContainer.className = 'arrow-container';
            const leftArrow = document.createElement('span');
            leftArrow.className = 'arrow-button';
            leftArrow.innerHTML = '←';
            leftArrow.addEventListener('click', () => nextSibling(-1));

            const messageNumber = document.createElement('span');
            messageNumber.className = 'message-number';
            const totalMsgCount = messagesArray.length;
            var currentMsgIndex = 1;
            messageNumber.innerHTML = `${currentMsgIndex} / ${totalMsgCount}`;

            const inputDiv = document.createElement('span');
            inputDiv.className = 'quick-input';
            inputDiv.style = "float: right";

            const inputField = document.createElement('input');
            inputField.className = 'quick-input-field';
            inputField.type = 'number';
            inputField.min = 1;
            inputField.max = totalMsgCount;
            inputField.placeholder = `${currentMsgIndex}`;

            inputField.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    selectSibling(parseInt(inputField.value));
                }
            });

            const goButton = document.createElement('button');
            goButton.innerHTML = 'Go';
            goButton.addEventListener('click', () => selectSibling(parseInt(inputField.value)));

            const rightArrow = document.createElement('span');
            rightArrow.className = 'arrow-button';
            rightArrow.innerHTML = '→';
            rightArrow.addEventListener('click', () => nextSibling(1));

            arrowContainer.appendChild(leftArrow);
            arrowContainer.appendChild(messageNumber);
            arrowContainer.appendChild(rightArrow);

            inputDiv.appendChild(inputField);
            inputDiv.appendChild(goButton);
            arrowContainer.appendChild(inputDiv);
            
            layerDiv.appendChild(arrowContainer);

            function nextSibling(offset) {
                console.log("currentMsg Index before: " + currentMsgIndex);

                currentMsgIndex = (currentMsgIndex + offset - 1 + totalMsgCount) % totalMsgCount + 1;

                console.log("currentMsg Index after: " + currentMsgIndex);

                selectSibling(currentMsgIndex);
            }

            function selectSibling(sibNumber) {
                if (isNaN(sibNumber) || sibNumber < 1 || sibNumber > totalMsgCount) {
                    return;
                }
                console.log(sibNumber);
                currentMsgIndex = sibNumber;
                messageNumber.innerHTML = `${currentMsgIndex} / ${totalMsgCount}`;
                inputField.value = currentMsgIndex;

                const nextMsgId = messagesArray[currentMsgIndex - 1];
               
                showMessage(messageDiv, msgId);
                clearChildren(childDiv);
                renderChildren(nextMsgId, childDiv);
                msgId = nextMsgId;
            }
        }
        layerDiv.appendChild(messageDiv);

        renderChildren(msgId, childDiv);
    }

    function clearChildren(parentContainer) {
        while (parentContainer.firstChild) {
            parentContainer.removeChild(parentContainer.firstChild);
        }
    }

    function renderChildren(parentId, parentContainer) {
        // Recursively render children
        childrenArray = getMessage(parentId).children;

        if (childrenArray.length > 0) {
            renderMsgLayer(childrenArray, childrenArray[0], parentContainer);
        }
    }

    // Function to render the contents of a conversation
    function renderConversation(conversationId) {
        conversation = conversationData.find(convo => convo.id === conversationId);

        if (!conversation) {
            convoContainer.innerHTML = '<p>Conversation not found</p>';
            return;
        }

        convoContainer.innerHTML = `<h2>${conversation.title}</h2>`;

        const systemMessageId = findSystemMessageId(conversation.mapping);
        const systemMsgChildren = getMessage(systemMessageId).children; // array of ids
        console.log(systemMsgChildren);
        // Recursively render all messages starting with systemMsg
        renderMsgLayer(systemMsgChildren, systemMsgChildren[0], convoContainer);
    }

    function getMessage(msgId) {
        return conversation.mapping[msgId];
    }

    // Function to find the ID of the root message
    function findSystemMessageId(mapping) {
        for (const messageId in mapping) {
            if (mapping.hasOwnProperty(messageId) && mapping[messageId].message.author.role === "system") {
                return messageId;
            }
        }
        return null;
    }

    // Function to render message content (handling multiple paragraphs)
    function showMessage(msgDiv, msgId) {
        msgDiv.innerHTML = `<p>${renderContent(msgId)}</p>`;
    }

    function showAuthor(authDiv, authorRole) {
        authDiv.innerHTML = `<p><b>${authorRole}</b></p>`;
    }

    function renderContent(messageId) {
        console.log("renderContent called");
        return getMessage(messageId).message.content.parts.join('').replace(/\n/g, '<br>');
    }

    // Render the initial conversation
    renderConversation(conversationData[0].id);
}

window.onload = initializeConversationViewer();